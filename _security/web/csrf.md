---
title:  "Cross Site Request Forgeries (CSRF/XSRF)"
topic: "web"
---
## Description
* Force a user to execute actions on a web application in which he is authenticated
* Actions limited by the capabilities exposed by the vulnerable application
* Actions limited by the privilege of the user
* CSRF mitigations can be defeated if XSS present

## Attack payloads
* HTML tags: `<img src="url">`, `<iframe src="url">`, `<script src="url">`
* Image object:
```
<script>
var img = new Image();
img.src = "url";
</script>
```
* `XMLHttp` object:
```
var req = new XMLHttpRequest();
req.open("POST", url, true);
req.onreadystatechange = function () {alert(req.responseText)};
req.send("arg=value");
```


## Prevention
**Why does it work ?**:
a request to a website automatically include any credentials associated with the site (session cookie).  
Consequence: the website cannot differentiate between the forged request and the legitimate request.  
Solution: a token/identifier not accessible by the attacker which is not sent with forged requests.  

**Influence of XSS**:
an XSS vulnerability can be exploited to defeat all CSRF mitigations.  

**Primary mitigation: tokens**
* Can be either stateful/stateless
* Stateful token: synchronizer token pattern. Token generated by a cryptographically secure large random number generator.
Should be unique per session. Added as hidden field or GET parameter.
* Stateless token: HMAC based pattern

**Forcing user interaction**
* Before executing an action on behalf of the user, force an interaction from the user
* Example: confirm dialog, reauthentification

**Custom request headers**


## Resources
* https://www.owasp.org/index.php/Testing_for_CSRF_(OTG-SESS-005)
* https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet
