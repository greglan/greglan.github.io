---
layout: page
title:  "Some exploitation tricks"
permalink: "tricks.html"
tags: [security, exploitation]
summary: "Various useful information when developing exploits"
---


## A few techniques
* In case a function is in an ASCII Armored Address Space, return to the PLT's
  entry address of that function.

  Limitation: the function must be used in the binary (have a PLT entry)

### ret2libc
* ret2libc targets: `system()` on Linux, `WinExec(), LoadLibraryA()` on Windows
* Limitation of ret2libc: injecting NULL bytes

#### ret2strcpy
* Particular case of ret2libc
* Works with functions that can copy memory blocks:
  `strcpy(), sprintf(), memcpy()...`
* Goal: return to `strcpy()` to copy code on an NX stack to a location with
  the X bit set.
* Stack layout:

```
(lower addresses)

&strcpy()   ; Address of strcpy() function
dest_ret    ; Where to go after the copy
dest        ; Executable location
src         ; Injected code address

(higher addresses)
```

#### ret2gets
* Particular case of ret2libc. Similar to ret2strcpy
* Works with functions that receive input:
  `gets(), read(), recv(), recvfrom()...`
* Stack layout:

```
(lower addresses)

&gets()     ; Address of gets() function
dest_ret    ; Where to go after
dest        ; Executable location

(higher addresses)
```

## ret2dl-resolve
* Return into the ELF's dynamic linker's resolver (*ld.so*) to return to
  functions in the PLT that are not used in the binary



## Tools
* [Custom tools](https://github.com/greglan/sec-tools)
* View instructions encoding of binary: `objdump -D -b binary -m i386 -M intel filename.bin`
* Memory map in file: `/proc/$PID/maps`
* Check the stack flags: `readelf -l prog_name | grep GNU_STACK`

### Compilation flags
* Enable GDB debugging symbols (gcc): `-ggdb`
* Compile for 32bit systems (gcc): `-m32`
* Disable stack smashing protection (gcc): `-fno-stack-protector`
* Allow stack execution (gcc): `-z execstack`
* Force 32 bits executables (ld): `-m elf_i386`


## Exploitation outside of a debugger
* Have exactly the same environment variables, otherwise the stack is shifted. Most notably, remove the `LINES` and `COLUMNS` variables in GDB
* Start the binary from the same directory, else some envar may change (`PWD, OLDPWD`)
* Use existing envar and try to keep the length the same
* Start the debugger and program using the absolute path
* [StackOverflow on exploitation outside GDB](https://stackoverflow.com/questions/17775186/buffer-overflow-works-in-gdb-but-not-without-it/17775966#17775966)
* [Test if a payload contains filtered bytes](https://github.com/greglan/sec-tools/blob/master/check_bad_bytes.py)
* Keep stdin open: `(cat /tmp/payload;cat) | `
* [Why SUID Binary exploit does not yield root shell](https://archive.cert.uni-stuttgart.de/vuln-dev/2003/03/msg00024.html)

### Fixing addresses
* Get addresses of buffers: `ltrace prog_name`
* Return to `printf` so that we get an output of what is the target. Then fix the addresses by trial and error [1]


## Resources and references
* [[1] Blopost on exploitation outside GDB](https://www.roguesecurity.in/2018/01/13/buffer-overflow-series-exploit-failing-outside-gdb/)
* [Example of function hooking in Linux using LD_PRELOAD](https://blog.netspi.com/function-hooking-part-i-hooking-shared-library-function-calls-in-linux/)
* [Another example of function hooking in Linux](https://opensourceforu.com/2011/08/lets-hook-a-library-function/)
* [Information about race conditions](https://www.win.tue.nl/~aeb/linux/hh/hh-9.html)
* [Binding TCP shellcode](https://reboare.github.io/slae/slae1.html)
* [The Shellcoder's handbook]
