---
layout: page
title:  "Protections"
permalink: "protections.html"
tags: [security, exploitation]
summary: "A review of some common exploit mitigation techniques"
---

## Address Space Layout Randomization (ASLR)
* Changes esp origin at each launch of a program. Text segment may not be affected
* Controlled system-wide by `/proc/sys/kernel/randomize_va_space`. Can be
[enabled](https://github.com/greglan/sec-tools/blob/master/enable_ASLR.sh) or [
disabled](https://github.com/greglan/sec-tools/blob/master/disable_ASLR.sh)
* Bypass: bruteforce or information leak

## Data Execution Prevention (DEP)
* NX bit on stack segment: prevent execution of shellcode.
  * NX bit: generic name
  * Intel name: XD (eXecute Disable) bit
  * AMD name: Enhanced Virus Protection (EVP)
  * ARM name: XN (eXecute Never) bit
* Solution: use existing code (ret2libc/ROP)
* Gcc flag for non executable stack: `-z execstack`
* 2 issues: some applications use self-modifying code, hardware support for
non-executable pages is lacking on some architectures [1]
* DEP on Windows since Windows XP SP2 and Windows 2003


## Stack smashing protection
* Also called stack cookie/canary
* GCC flag: `-fstack-protector`
* Solution: non stack-based vulnerabilities
* Used on Windows since Windows XP SP2 and Windows 2003


## RELocations Read Only (RELRO)
* Hardens the data sections of an ELF binary/process
* Hardens ELF programs against loader memory area overwrites by having the
loader mark any areas of the relocation table as read-only for any symbols
resolved at load-time
* Reduces the area of possible GOT-overwrite-style memory corruption attacks
* Two mode of operations: partial RELRO and full RELRO

### Partial RELRO
* Compiler flags: `-Wl,-z,relro`, passed to the linker as `-z relro`
* ld option `-z relro`: tell the dynamic linker to defer function call
resolution to the point when the function is called (lazy binding), rather than
at load time. Lazy binding is the default
* ELF sections reordered so that the ELF internal data sections
(.got, .dtors, etc.) precede the program's data sections (.data and .bss)
* Prevents the data sections from being overwritten in case of a .data
or .bss overflow
* Read-only Non-PLT GOT
* GOT writeable

### Full RELRO
* Compiler flags: `-Wl,-z,relro,-z,now`, passed to the linker as `-z relro -z now`
* ld option `-z now`: tells the dynamic linker to resolve all symbols when the
program is started, or when the shared library is linked to using `dlopen`,
instead of deferring function call resolution to the point when the function is
first called (lazy binding)
* Includes the features of partial RELRO
* Entire GOT (re)mapped as read-only
* Prevents the modification of GOT entries to redirect execution flow
* Applies to .ctors, .dtors, .jcr, .dynamic and .got


## SMEP/SMAP
* SMEP: Supervisor Mode Execution Protection. Used to prevent supervisor mode
from unintentionally executing user-space code
* SMAP: Supervisor Mode Access Prevention. Feature of some CPU which allows
supervisor mode programs to set user-space memory mappings so that access to
those mappings from supervisor mode will cause a trap. Makes it harder for
programs to "trick" the kernel into using instructions or data from a user-space
program
* SMAP activation: CR4 control register
* Drawback of SMAP: larger kernel size and slower userspace memory accesses
* [New CR4 bits protection](https://www.phoronix.com/scan.php?page=news_item&px=Linux-Protect-Special-CR4-Bits)


## Other protections
* [SafeSEH](/seh.html)
* [PIE/PIC](elf.html#position-independent-executables-pie).
Solution: information leak
* Bounds checking GCC extension. Principle: check that buffer accesses remain in
bounds. Drawbacks: slowdown of 10 times. [1]
* Static verification. Drawbacks: fails on complex programs, hard to implement.
* Dynamic analysis using Valgrind. Problem: not exhaustive.
* Fortify source
* Heap protector
* Control Flow Graph Integrity (CFGI).
[Clang implementation](https://clang.llvm.org/docs/ControlFlowIntegrity.html)
* [Clang ShadowCallStack on AArch64](https://clang.llvm.org/docs/ShadowCallStack.html)
* Pointer obfuscation: some pointers stored in glibc are obfuscated via PTR_MANGLE/PTR_UNMANGLE macros
internally in glibc, preventing libc function pointers from being overwritten
during runtime.

## Resources and references
* [1] *Hagen Fritsch*, Buffer overflows on linux-x86-64, Black Hat Europe.
* Aleph One, *Smashing The Stack For Fun And Profit*. Phrack 49.
* [Azeria Labs](https://azeria-labs.com/process-memory-and-memory-corruption/)
* [SMAP Wikipedia article](https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention)
* [Linux binary hardening review](https://capsule8.com/blog/millions-of-binaries-later-a-look-into-linux-hardening-in-the-wild/)
* [3] ld manpage
* [Hexcellent](http://security.cs.pub.ro/hexcellents/wiki/kb/exploiting/home)
* Linux exploit writing tutorial part 2 - Stack Overflow ASLR bypass using ret2reg
* Exploiting Format String vulnerabilities, TESO security group
